# Module_19_5_DjangoBlog

<h1>Добавление постраничной разбивки в представление списка постов</h1>
  Отредактируйте файл views.py приложения blog, импортировав класс Django 
Paginator и видоизменив представление post_list, как показано ниже:

```
from django.shortcuts import render, get_object_or_404
from .models import Post
from django.core.paginator import Paginator        # добавляем это

def post_list(request):
   post_list = Post.published.all()
   # Постраничная разбивка с 3 постами на страницу
   paginator = Paginator(post_list, 3)             # добавляем это
   page_number = request.GET.get('page', 1)        # добавляем это
   posts = paginator.page(page_number)
  
   return render(request,
     'blog/post/list.html',
     {'posts': posts})
```

  Давайте рассмотрим новый исходный код, который был добавлен в представление.
1. Мы создаем экземпляр класса Paginator с числом объектов, возвращаемых в  расчете на страницу. Мы будем отображать по три поста на страницу.
2. Мы извлекаем HTTP GET-параметр page и сохраняем его в переменной 
page_number. Этот параметр содержит запрошенный номер страницы. 
Если параметра page нет в GET-параметрах запроса, то мы используем 
стандартное значение 1, чтобы загрузить первую страницу результатов.
3. Мы получаем объекты для желаемой страницы, вызывая метод page()
класса Paginator. Этот метод возвращает объект Page, который хранится 
в переменной posts.
4. Мы передаем номер страницы и объект posts в шаблон.

<h1>Создание шаблона постраничной разбивки</h1>
  Далее необходимо создать навигацию по страницам, чтобы пользователи 
имели возможность просматривать разные страницы. Мы создадим шаблон 
отображения постранично разбитых ссылок и сделаем его типовым, чтобы 
иметь возможность реиспользовать шаблон для постраничной разбивки любого объекта на веб-сайте.
  Внутри каталога templates/ создайте новый файл и назовите его pagination.
html. Добавьте в файл следующий ниже исходный код HTML:

```
<div class="pagination">
   <span class="step-links">
     {% if page.has_previous %}
       <a href="?page={{ page.previous_page_number }}">Previous</a>
     {% endif %}
     <span class="current">
       Page {{ page.number }} of {{ page.paginator.num_pages }}.
     </span>
     {% if page.has_next %}
       <a href="?page={{ page.next_page_number }}">Next</a>
     {% endif %}
   </span>
</div>
```

  Это типовой шаблон постраничной разбивки. Предполагается, что данный 
шаблон будет иметь в контексте объект Page, чтобы прорисовывать предыдущую и следующую ссылки, а также отображать текущую страницу и общее 
число страниц результатов.
  Давайте вернемся к шаблону blog/post/list.html и разместим шаблон pagination.html в нижней части блока {% content %}, как показано ниже:

```
{% extends "blog/base.html" %}
{% block title %}My Blog{% endblock %}
{% block content %}
   <h1>My Blog</h1>
   {% for post in posts %}
     <h2>
       <a href="{{ post.get_absolute_url }}">
         {{ post.title }}
       </a>
     </h2>
     <p class="date">
       Published {{ post.publish }} by {{ post.author }}
     </p>
     {{ post.body|truncatewords:30|linebreaks }}
   {% endfor %}
   {% include "pagination.html" with page=posts %}       # добавляем это
{% endblock %}
```

  Шаблонный тег {% include %} загружает данный шаблон и  прорисовывает его с  использованием текущего контекста шаблона. 
Ключевое слово with используется для того, чтобы передавать дополнительные контекстные 
переменные в шаблон. Для прорисовки в шаблоне постраничной разбивки 
используется переменная page, при этом объект Page, который мы передаем 
из представления в  шаблон, называется posts. Мы используем выражение 
with page=posts, чтобы передавать переменную, ожидаемую шаблоном постраничной разбивки. Описанному методу можно следовать для применения шаблона постраничной разбивки для любого типа объекта.



